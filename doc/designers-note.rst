
設計メモ
========

.. note::
  このドキュメントは，デザイン用のメモ書きです．
  
  リリース版の Etude には含まれません．


テスト方針
----------

- Etude のテストは，原則として :file:`test` ディレクトリに置く

- :file:`etude/hoge.hpp` に対するテストのファイル名は， :file:`test/hoge-{000}-pass.cc` または :file:`test/hoge-{001}-fail.cc` のように指定される

  - :file:`etude/hoge/fuga.hpp` に対するテストは :file:`test/hoge/fuga-{000-pass}.cc` のように指定される
  - "-pass.cc" で終わるテストは，コンパイルに成功し，正しく実行されることが期待される
  - "-fail.cc" で終わるテストは，コンパイルに失敗することが期待される

- :file:`test/{hoge}-000-pass.cc` のように， "000" の番号を振られたテストは，原則としてヘッダ依存に関する最小限のテストを行う

  - 典型的には ::
    
      #include "../etude/hoge.hpp"
      // 他のヘッダは #include しない
      
      int main()
      {
        static_assert( ETUDE_VERSION >= 0, "<etude/version.hpp> must be included" );
        
        // 最低限，名前があることは確認しておく
        etude::hoge( 0, 1, 2 );
        
        // ...
        
      }
    
    となる

- それ以降のテストは原則として自由に行う
  
  - 基本的には，一つ一つのテスト項目に対し，同じ通し番号を振られた pass と fail の対でテストする
  - 何らかの事情で pass と fail のどちらかを用意できない場合には，欠番にしておけば良い
  - 必要に応じて， :file:`test/hoge-002-{compound_case}-pass.cc` のように，通し番号の次に，テスト内容に関する端的な説明を入れても良い
  
    - その場合でも，自動テストが行い易いよう，終わりは必ず "-pass.cc" または "-fail.cc" にする

- テストツールは， Boost.Test があるなら それを使い，無いならば ``ASSERT`` で強引にテストする


雑多なメモ
----------

- 英語対応方針はどうする？

  - するべきか否か，と訊かれれば，当然「するべき」なのは間違いない
  - 問題になるのはコストであり，コストがかかる場合，開発から離れがちになる可能性がある
  - さらに，日本語と英語のどちらを正式なものとするべきか，という問題も
  
    - 日本語を母語とするプログラマ（特に自分）にとっての利便性を考えると，日本語のドキュメントを提供しない，という選択肢は存在しない
    - 作者の母語が日本語である以上，正式なものは日本語にした方が，いろいろと楽なのは間違いない
    - 一方で，どうせ英語で書くなら，プログラマの絶対数は日本語話者以外が圧倒的に多い以上，そちらを正式版にしたほうが，彼らにとっては扱いやすくなる
    - ソースコードのコメントはどうするべきか
  
  - 今のところは日本語を使うことにするが，変更は大いに有り得る

- SFINAE 対応はどうするか？

  - SFINAE を使うメリット
    
    - メタプログラミングを行い易い
    - 型変換など，きめ細やかな対応ができる
  
  - SFINAE を使うデメリット
  
    - コンパイラによって対応状況が違う． バグが出やすい
    - 慣れない人にはエラーメッセージが分かりにくくなる
  
  - 基本方針としては， SFINAE は行わない
    
    - ただし，コンストラクタや演算子多重定義，それに準ずる関数呼び出しでは， SFINAE を行う
    
      - 「それに準ずる関数呼び出し」とは， ``copy`` や ``cast`` などのこと． ドキュメントに明記する
      - タグ付きコンストラクタの場合には SFINAE は行わない
    
    - 名前空間を使うなどして， SFINAE 有り版を用意してもいい

- Perfect Forward に対する対応について

  - 既存の Perfect Forward には問題がある
  
    - 非 const の参照を，そのまま転送できてしまう
    
      - ``f(x)`` という形から ``x`` が変更される可能性を予期できない
      - 折角 ``std::ref`` という参照をラップする手段が用意されたので，そっちを使ってもらいたい
    
    - ``std::forward`` は ``constexpr`` ではないので ``constexpr`` 性を伝搬できない
  
  - 三種類の forwarding policy を用意し，使い分ける
  
    - １． Reference Forwarding
      
      - 標準ライブラリの forwarding policy
      - 全て参照として，そのまま伝搬する
      - 非 ``const`` な lvalue reference を そのまま転送できる，唯一の方法
      - 一回でも他の Forwarding Policy が使われると，それに影響される
      
        - 多段の転送がかかる場合は，こちらを使う
    
    - ２． Safe Reference Forwarding
    
      - 「安全な」 Forwarding Policy
      - lvalue reference は ``const`` を付加して伝搬する
      
        - 非 ``const`` な lvalue reference を転送したい場合には ``std::ref`` のような特別な仕組みを用意する
      
      - rvalue reference は そのまま伝搬する
    
    - ３． Normal Forwarding
    
      - ``std::make_tuple`` と似た forwarding policy
      - まず lvalue reference なら ``const`` を付与する
      - その後， ``decay`` により参照から値に変更する
      
        - ``std::reference_wrapper`` に包まれていた場合，参照に変換する
